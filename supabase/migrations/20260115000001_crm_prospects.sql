-- CRM System: Prospects, Interactions, Product Movements and Payments
-- This migration creates the complete CRM system for tracking prospects/clients
-- and managing product movements (samples, consignments, sales)

-- 1. Prospects Table - Tracks potential B2B and B2C clients
CREATE TABLE prospects (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  type TEXT NOT NULL CHECK (type IN ('b2b', 'b2c')),
  stage TEXT NOT NULL DEFAULT 'contact' CHECK (stage IN (
    'contact', 'interested', 'sample_sent', 'negotiation', 'converted', 'lost'
  )),
  company_name TEXT,
  contact_name TEXT NOT NULL,
  email TEXT NOT NULL,
  phone TEXT,
  tax_id TEXT,
  notes TEXT,
  converted_to_client_id UUID, -- References b2b_clients.id or users.id when converted
  converted_to_type TEXT CHECK (converted_to_type IN ('b2b', 'b2c')),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_prospects_type ON prospects(type);
CREATE INDEX idx_prospects_stage ON prospects(stage);
CREATE INDEX idx_prospects_email ON prospects(email);
CREATE INDEX idx_prospects_created ON prospects(created_at DESC);

-- 2. Prospect Interactions - History of all interactions with prospects
CREATE TABLE prospect_interactions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  prospect_id UUID REFERENCES prospects(id) ON DELETE CASCADE NOT NULL,
  interaction_type TEXT NOT NULL CHECK (interaction_type IN (
    'call', 'email', 'meeting', 'note', 'sample_sent', 'quote_sent', 'other'
  )),
  subject TEXT,
  notes TEXT NOT NULL,
  created_by UUID REFERENCES users(id), -- Admin user who created the interaction
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_interactions_prospect ON prospect_interactions(prospect_id);
CREATE INDEX idx_interactions_created ON prospect_interactions(created_at DESC);

-- 3. Product Movements - Tracks all product movements (samples, consignments, sales)
CREATE TABLE product_movements (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  movement_type TEXT NOT NULL CHECK (movement_type IN (
    'sample', 'consignment', 'sale_invoice', 'sale_credit'
  )),
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN (
    'pending', 'delivered', 'returned', 'sold', 'paid', 'partial_paid', 'overdue'
  )),
  prospect_id UUID REFERENCES prospects(id) ON DELETE SET NULL,
  b2b_client_id UUID REFERENCES b2b_clients(id) ON DELETE SET NULL,
  customer_user_id UUID REFERENCES users(id) ON DELETE SET NULL, -- For B2C
  movement_number TEXT UNIQUE, -- Human-readable reference number (generated by trigger)
  items JSONB NOT NULL, -- Array of {product_id, variant_id, quantity, unit_price}
  total_amount DECIMAL(10,2) NOT NULL DEFAULT 0,
  amount_paid DECIMAL(10,2) NOT NULL DEFAULT 0,
  due_date DATE, -- For credit sales and consignments
  delivery_date DATE, -- When products were actually delivered
  notes TEXT,
  created_by UUID REFERENCES users(id), -- Admin user who created the movement
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_movements_type ON product_movements(movement_type);
CREATE INDEX idx_movements_status ON product_movements(status);
CREATE INDEX idx_movements_prospect ON product_movements(prospect_id);
CREATE INDEX idx_movements_b2b_client ON product_movements(b2b_client_id);
CREATE INDEX idx_movements_customer ON product_movements(customer_user_id);
CREATE INDEX idx_movements_due_date ON product_movements(due_date);
CREATE INDEX idx_movements_created ON product_movements(created_at DESC);

-- 4. Movement Payments - Tracks payments for product movements
CREATE TABLE movement_payments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  movement_id UUID REFERENCES product_movements(id) ON DELETE CASCADE NOT NULL,
  amount DECIMAL(10,2) NOT NULL,
  payment_method TEXT NOT NULL CHECK (payment_method IN (
    'cash', 'transfer', 'check', 'credit_card', 'other'
  )),
  payment_reference TEXT, -- Transaction number, check number, etc.
  notes TEXT,
  paid_at TIMESTAMPTZ DEFAULT NOW(),
  created_by UUID REFERENCES users(id), -- Admin user who recorded the payment
  created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE INDEX idx_payments_movement ON movement_payments(movement_id);
CREATE INDEX idx_payments_paid_at ON movement_payments(paid_at DESC);

-- Function to generate movement number
CREATE OR REPLACE FUNCTION generate_movement_number()
RETURNS TRIGGER AS $$
DECLARE
  prefix TEXT;
  year_part TEXT;
  sequence_num INTEGER;
  new_number TEXT;
BEGIN
  -- Skip if movement_number is already set
  IF NEW.movement_number IS NOT NULL THEN
    RETURN NEW;
  END IF;
  
  -- Set prefix based on movement type
  prefix := CASE NEW.movement_type
    WHEN 'sample' THEN 'MUE'
    WHEN 'consignment' THEN 'CON'
    WHEN 'sale_invoice' THEN 'VEN'
    WHEN 'sale_credit' THEN 'CRE'
    ELSE 'MOV'
  END;
  
  -- Get year part
  year_part := TO_CHAR(NOW(), 'YY');
  
  -- Get next sequence number for this type and year
  SELECT COALESCE(MAX(CAST(SUBSTRING(movement_number FROM '[0-9]+$') AS INTEGER)), 0) + 1
  INTO sequence_num
  FROM product_movements
  WHERE movement_number LIKE prefix || '-' || year_part || '-%'
    AND EXTRACT(YEAR FROM created_at) = EXTRACT(YEAR FROM NOW());
  
  -- Format: PREFIX-YY-NNNN (e.g., MUE-25-0001)
  new_number := prefix || '-' || year_part || '-' || LPAD(sequence_num::TEXT, 4, '0');
  
  NEW.movement_number := new_number;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-generate movement number
CREATE TRIGGER trigger_generate_movement_number
  BEFORE INSERT ON product_movements
  FOR EACH ROW
  EXECUTE FUNCTION generate_movement_number();

-- Function to update movement status based on payments
CREATE OR REPLACE FUNCTION update_movement_payment_status()
RETURNS TRIGGER AS $$
DECLARE
  movement_total DECIMAL(10,2);
  movement_paid DECIMAL(10,2);
  movement_due_date DATE;
BEGIN
  -- Get movement totals
  SELECT total_amount, amount_paid, due_date
  INTO movement_total, movement_paid, movement_due_date
  FROM product_movements
  WHERE id = NEW.movement_id;
  
  -- Recalculate amount_paid
  SELECT COALESCE(SUM(amount), 0)
  INTO movement_paid
  FROM movement_payments
  WHERE movement_id = NEW.movement_id;
  
  -- Update movement
  UPDATE product_movements
  SET 
    amount_paid = movement_paid,
    status = CASE
      WHEN movement_paid >= movement_total THEN 'paid'
      WHEN movement_paid > 0 THEN 'partial_paid'
      WHEN movement_due_date IS NOT NULL AND movement_due_date < CURRENT_DATE AND movement_paid < movement_total THEN 'overdue'
      ELSE status
    END,
    updated_at = NOW()
  WHERE id = NEW.movement_id;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to update movement status when payment is added
CREATE TRIGGER trigger_update_movement_on_payment
  AFTER INSERT ON movement_payments
  FOR EACH ROW
  EXECUTE FUNCTION update_movement_payment_status();

-- Function to handle inventory changes for product movements
CREATE OR REPLACE FUNCTION handle_movement_inventory()
RETURNS TRIGGER AS $$
DECLARE
  item RECORD;
  current_quantity INTEGER;
  current_reserved INTEGER;
BEGIN
  -- Only process when status changes to 'delivered' or 'returned'
  IF TG_OP = 'UPDATE' AND OLD.status = NEW.status THEN
    RETURN NEW;
  END IF;
  
  -- Process items based on movement type and status
  FOR item IN SELECT * FROM jsonb_array_elements(NEW.items) AS items
  LOOP
    -- Get current inventory
    SELECT quantity, reserved_quantity
    INTO current_quantity, current_reserved
    FROM inventory
    WHERE product_id = (item->>'product_id')::UUID
      AND (item->>'variant_id')::UUID IS NOT DISTINCT FROM (item->>'variant_id')::UUID;
    
    -- Handle different movement types and statuses
    IF NEW.movement_type = 'sample' AND NEW.status = 'delivered' THEN
      -- Samples: Decrease quantity directly
      UPDATE inventory
      SET quantity = GREATEST(0, quantity - (item->>'quantity')::INTEGER),
          updated_at = NOW()
      WHERE product_id = (item->>'product_id')::UUID
        AND (variant_id IS NULL OR variant_id = (item->>'variant_id')::UUID);
        
    ELSIF NEW.movement_type = 'consignment' THEN
      IF NEW.status = 'delivered' THEN
        -- Consignment: Move to reserved
        UPDATE inventory
        SET 
          quantity = GREATEST(0, quantity - (item->>'quantity')::INTEGER),
          reserved_quantity = COALESCE(reserved_quantity, 0) + (item->>'quantity')::INTEGER,
          updated_at = NOW()
        WHERE product_id = (item->>'product_id')::UUID
          AND (variant_id IS NULL OR variant_id = (item->>'variant_id')::UUID);
          
      ELSIF NEW.status = 'returned' THEN
        -- Returned consignment: Move back from reserved to quantity
        UPDATE inventory
        SET 
          reserved_quantity = GREATEST(0, COALESCE(reserved_quantity, 0) - (item->>'quantity')::INTEGER),
          quantity = quantity + (item->>'quantity')::INTEGER,
          updated_at = NOW()
        WHERE product_id = (item->>'product_id')::UUID
          AND (variant_id IS NULL OR variant_id = (item->>'variant_id')::UUID);
          
      ELSIF NEW.status = 'sold' THEN
        -- Consignment sold: Remove from reserved (already counted as sale)
        UPDATE inventory
        SET 
          reserved_quantity = GREATEST(0, COALESCE(reserved_quantity, 0) - (item->>'quantity')::INTEGER),
          updated_at = NOW()
        WHERE product_id = (item->>'product_id')::UUID
          AND (variant_id IS NULL OR variant_id = (item->>'variant_id')::UUID);
      END IF;
      
    ELSIF NEW.movement_type IN ('sale_invoice', 'sale_credit') AND NEW.status = 'delivered' THEN
      -- Sales: Decrease quantity directly
      UPDATE inventory
      SET quantity = GREATEST(0, quantity - (item->>'quantity')::INTEGER),
          updated_at = NOW()
      WHERE product_id = (item->>'product_id')::UUID
        AND (variant_id IS NULL OR variant_id = (item->>'variant_id')::UUID);
    END IF;
  END LOOP;
  
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger to handle inventory changes
CREATE TRIGGER trigger_movement_inventory
  AFTER INSERT OR UPDATE OF status ON product_movements
  FOR EACH ROW
  EXECUTE FUNCTION handle_movement_inventory();

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Triggers for updated_at
CREATE TRIGGER update_prospects_updated_at
  BEFORE UPDATE ON prospects
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_movements_updated_at
  BEFORE UPDATE ON product_movements
  FOR EACH ROW
  EXECUTE FUNCTION update_updated_at_column();

-- Enable RLS
ALTER TABLE prospects ENABLE ROW LEVEL SECURITY;
ALTER TABLE prospect_interactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE product_movements ENABLE ROW LEVEL SECURITY;
ALTER TABLE movement_payments ENABLE ROW LEVEL SECURITY;

-- RLS Policies: Only admins can access CRM data
CREATE POLICY "Admins can view all prospects"
  ON prospects FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role = 'admin'
    )
  );

CREATE POLICY "Admins can insert prospects"
  ON prospects FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role = 'admin'
    )
  );

CREATE POLICY "Admins can update prospects"
  ON prospects FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role = 'admin'
    )
  );

CREATE POLICY "Admins can view all interactions"
  ON prospect_interactions FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role = 'admin'
    )
  );

CREATE POLICY "Admins can insert interactions"
  ON prospect_interactions FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role = 'admin'
    )
  );

CREATE POLICY "Admins can view all movements"
  ON product_movements FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role = 'admin'
    )
  );

CREATE POLICY "Admins can insert movements"
  ON product_movements FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role = 'admin'
    )
  );

CREATE POLICY "Admins can update movements"
  ON product_movements FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role = 'admin'
    )
  );

CREATE POLICY "Admins can view all payments"
  ON movement_payments FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role = 'admin'
    )
  );

CREATE POLICY "Admins can insert payments"
  ON movement_payments FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM users
      WHERE users.id = auth.uid()
      AND users.role = 'admin'
    )
  );
